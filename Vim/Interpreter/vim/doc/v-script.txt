*v#script.txt*      Tokens, functions, debugging (large)
Script ~

1. IF						|v#if| 
2. FOR 						|v#for|
3. VARIABLE					|v#variable|
4. STRING 					|v#string|
5. ARITHMETIC 				|v#arithmetic|
6. FUNCTION					|v#funciton-script|
7. VIMGREP					|v#vimgrep|
8. COMMAND LINE				|v#commandline|
9. OUTPUT					|v#output|
10.	DEBUG, VERBOSE			|v#debug|






>bash
vim -u NONE -N
set -o vi   		 Linux term 
<bash

%!xxd [-r][-g 1]
%!column -t         " Align column
:sort [u][n]		" Remove duplicates treats 100 after 20


>vim
:set ntformat=		" Treat all numerical as decimal even if preceded by 0 
:arg **/*.cpp
:argadd
:argdo %/foo/bar/g

:TOhtml
:saveas
:w !sudo tee %     	" write out the current file using sudo
:sh[ell]			" Goto shell, then exit to come back
env | grep -i vim # in shell to know I am from vim 
vim -w scriptname # to record each keystrike
yy:@"
call feedkeys("i\<C-V>\<C-X>")
:e **/CardGame.java
<c-d> in ex to show a list of completion

	:.= 			" show line number

	:py print 2
	:version
	:h +feature-list
	:h ex-cmd-index
	:t move 
	q::%y
	q/:%y
	:oldfiles
	:browse oldfiles


   :unlet g:max  	"delete unlet a variable 
   :put =range(11,15)	"put 1 2 3 at the cursor place  rang is a funciton 
  feedkeys 
<vim

-------------------------------------------------------------------------------
                                                *v#if*

>vim
   if <expression>
   	...
   elseif <expression>
   	...
   else
   	...
   endif
   if l:string =~ "y*"
      let g:tmp ="True"
   endif " Don't forget that endif 
<vim
Expression can be : 
   <string> == <string> : String equals.
   <string> != <string> : String does not equal.
   <string> =~ <pattern>: String matches pattern.
   <string> !~ <pattern>: String doesn’t match pattern.
   <operator>#          : Additionally match case.
   <operator>?          : Additionally don’t match case.
   exists('var')	; Check if varaible exists 

-------------------------------------------------------------------------------
                                                 *v#for*
>vim
  for <var> in <list>
  	continue 	" return to the begining of loop 
  	break		" stop the loop and exit 
  endfor
  
  for l:var in range(30)
  for [var1, var2] in [[1, 2], [3, 4]]
  	" on 1st loop, var1 = 1 and var2 = 2
  	" on 2nd loop, var1 = 3 and var2 = 4
  endfor


  while <expression>
  endwhile

  while l:bool

  try
  	...
  catch <pattern (optional)>
  	" HIGHLY recommended to catch specific error.
  finally
  	...
  endtry
<vim


-------------------------------------------------------------------------------
                                                 *v#variables*
>vim
g:var " global.
a:var " function argument.
l:var " local to function.
b:var " local to buffer.
w:var " local to window.
t:var " local to tab.
v:var " Predefined by Vim.
<vim

<Number>: 32-bit signed number.
>vim
    -123
    0x10
    0177
<vim
<Float>: Floating point number. Requires +float on vim compile
>vim
    123.456
    1.15e-6
    -1.1e3
<vim
<String>: NUL terminated string of 8-bit unsigned characters.
>vim
    "ab\txx\"--"
    'x-z''a,c'
<vim
<Funcref>: A reference to a function. Variables used for funcref objects must start with a capital letter.
>
    :let Myfunc = function("strlen")
    :echo Myfunc('foobar') " Call strlen on 'foobar'.
<
<List>: An ordered sequence of items.
>
    :let mylist = [1, 2, ['a', 'b']]
    :echo mylist[0]
    1
    :echo mylist[2][0]
    a
    :echo mylist[-2]
    2
    :echo mylist[999]
    E684: list index out of range: 999
    :echo get(mylist, 999, "THERE IS NO 1000th ELEMENT")
    THERE IS NO 1000th ELEMENT
<
<Dictionary>: An associative, unordered array. Each entry has a key and a value.
>
    :let mydict = {'blue': "#0000ff", 'foo': {999: "baz"}}
    :echo mydict["blue"]
    #0000ff
    :echo mydict.foo
    {999: "baz"}
    :echo mydict.foo.999
    baz
    :let mydict.blue = "BLUE"
    :echo mydict.blue
    BLUE
<

-------------------------------------------------------------------------------
                                                 *v#string*


>vim
  :5,8del | let l=split(@","\n") | 1,4s/$/\=remove(l,0)/
<vim
  1/ del
  2/ split buffer
  3/ remove(l,0) delete first elt of list l and return it :)
  
   will transfor : 
  work it 
  make it 
  do it 
  makes us 
  harder
  better
  faster
  stronger
  ~
  in 
  work it harder
  make it better
  do it faster
  makes us stronger
  

-------------------------------------------------------------------------------
                                                 *v#arithmetic*

>vim
  let result=(100*21)/23
  :echo printf("%d.%02d",result/100,result%100)

  %s/[0-9.]\+/\=2.0*str2float(submatch(0))/g 
<vim
      [0-9.]\+    one or more digits or periods
      \=  ...  evaluate following expression
      2.0 ... obvious
      *    ... also obvious
      str2float(submatch(0))  take entire match and convert that string to a float
      /g ...  as many matches as possible per line 

  %s/\%8c\d*/\=submatch(0)*100  # for column 8, means string number 8 
  %s/\d\+/\=submatch(0)+2/g     # find all integer and add 2 to its
  :s/|\(\d\+\)/\='|'.(submatch(1)*60)/g
  :s/|\(\d\+\):\(\d\+\)/\='|'.(submatch(1)+submatch(2))/g
    transform 
    |23:58|6:40|
    |12:45|0:25|
    |36:13|12:00|
    in 
    |81|46|
    |57|25|
    |49|12|


				                 *hex2int*
HEX TO INT ~
>vim
  "IN command 
  :echo 0x123455 " will echo the dec value 
  :echo printf('%x',74565)

  "IN insert 
  <C-R>=0x09ab<Enter>  "will insert 2475
  <C-R>=printf('0x%04x',2475)<Enter> "will insert 0x09ab
  ctrl-R + ctrl-W "paste in command move, the wrold under cursor 
<vim

						*hex-dump*
HEX DUMP ~
>
	:r !xxd sample.bin 
<		To get a list of Hex and their adresss
>
	:r !xxd --help 
	:r !xxd -i sample.bin
<		Convert it to a C char[]
>
	vim -b binfile.bin 
	:setlocal disaplay=hex
	:%!xxd
	:%!xxd -r
<		Convert buffer to hex dump and convet back 


						*v#function-script*
Function are defined like 
>
  function! (arg1,arg2) 
  endfunction
<
  Where we dont know the |type()| of the argument, the ! silently forces reload if function is defined yet 

NOTE:  
  The undo and search pattern are restored after function call. Yo umust change it explicitely |search-script|



-------------------------------------------------------------------------------
Change the mysearch pattern 
						 *search-script*	
>vim
  fun! X()
      /Hello
      let @/ = 'Hello'
  endfun

  redir @a 
  call bla()
  redir END 
<vim
-------------------------------------------------------------------------------

command! -nargs=1 MyCommand call s:MyFunc(<f-args>) " transform a function to user-command



																	 *v#vimgrep*

>vim
:vimgrep /pattern/ {file} " search for pattern in multiple files
:vimgrep /foo/ **/*

:cn - jump to the next match
:cp - jump to the previous match
:copen - open a window containing the list of matches
cnfile   # first quickfixt in the next file 
colder 
<vim


														   *v#debug* *v#verbose*

DEBUG ~


:digraph show the digraph that can be inserted with Ck

From http://vim.wikia.com/wiki/Displaying_the_current_Vim_environment

>vim
:abbreviate   - list abbreviations
:args         - argument list
:augroup      - augroups
:autocmd      - list auto-commands
:buffers      - list buffers
:breaklist    - list current breakpoints
:cabbrev      - list command mode abbreviations
:changes      - changes
:cmap         - list command mode maps
:command      - list commands
:compiler     - list compiler scripts
:digraphs     - digraphs
:file         - print filename, cursor position and status (like Ctrl-G)
:filetype     - on/off settings for filetype detect/plugins/indent
:function     - list user-defined functions (names and argument lists but not the full code)
:function Foo - user-defined function Foo() (full code list)
:highlight    - highlight groups
:history c    - command history
:history =    - expression history
:history s    - search history
:history      - your commands
:iabbrev      - list insert mode abbreviations
:imap         - list insert mode maps
:intro        - the Vim splash screen, with summary version info
:jumps        - your movements
:language     - current language settings
:let          - all variables
:let FooBar   - variable FooBar
:let g:       - global variables
:let v:       - Vim variables
:list         - buffer lines (many similar commands)
:lmap         - language mappings (set by keymap or by lmap)
:ls           - buffers
:ls!          - buffers, including "unlisted" buffers
:map!         - Insert and Command-line mode maps (imap, cmap)
:map          - Normal and Visual mode maps (nmap, vmap, xmap, smap, omap)
:map<buffer>  - buffer local Normal and Visual mode maps
:map!<buffer> - buffer local Insert and Command-line mode maps
:marks        - marks
:menu         - menu items
:messages     - message history
:nmap         - Normal-mode mappings only
:omap         - Operator-pending mode mappings only
:print        - display buffer lines (useful after :g or with a range)
:reg          - registers
:scriptnames  - all scripts sourced so far
:set all      - all options, including defaults
:setglobal    - global option values
:setlocal     - local option values
:set          - options with non-default value
:set termcap  - list terminal codes and terminal keys
:smap         - Select-mode mappings only
:spellinfo    - spellfiles used
:syntax       - syntax items
:syn sync     - current syntax sync mode
:tabs         - tab pages
:tags         - tag stack contents
:undolist     - leaves of the undo tree
:verbose      - show info about where a map or autocmd or function is defined
:version      - list version and build options
:vmap         - Visual and Select mode mappings only
:winpos       - Vim window position (gui)
:xmap         - visual mode maps only
<vim

>vim
:python -m pdb script.py
:debug CommandName						" debug a command
:debug call FunctionName(arg)  			" debug a fucntion
vim -D  # open the debugger.
		:verbose set ft ?
		:syntax list 
		:scriptnames
<vim

gdb 	https://vi.stackexchange.com/questions/2046/how-can-i-integrate-gdb-with-vim
		https://www.cprogramming.com/gdb.html
java 	http://eclim.org/vim/java/debug.html
vim		http://inlehmansterms.net/2014/10/31/debugging-vim/




PATH ~
  " Relative path of script file:
  let s:path = expand('<sfile>')
  
  " Absolute path of script file:
  let s:path = expand('<sfile>:p')
  
  " Absolute path of script file with symbolic links resolved:
  let s:path = resolve(expand('<sfile>:p'))
  
  " Folder in which script resides: (not safe for symlinks)
  let s:path = expand('<sfile>:p:h')
  
  " If you're using a symlink to your script, but your resources are in
  " the same directory as the actual script, you'll need to do this:
  "   1: Get the absolute path of the script
  "   2: Resolve all symbolic links
  "   3: Get the folder of the resolved absolute file
  let s:path = fnamemodify(resolve(expand('<sfile>:p')), ':h')


																 *v#commandline*


<c-e>			" End of cmd (goto)		
<c-b>			" Beginging of cmd (goto)
<c-l>			" Longest common match
<c-n>			"
<c-p>			"
<c-a>			" expand ** like bd **.xml<c-a>
<c-d>			" Display matches: b *.c<c-d>
<c-r><c-w>		" Get word under cursor

|				" Cmd separator
:@"				" Execute register content 
:e +ff=unix
:w +ff=dos
	<c-v> or <c-k> to insert char that are nto on keyboard
	:h command-complete when want auto completion for custom cmd 
	<c-r><c-w> in cmdline get the word under cursor (esee :h c_CTRL-W_...)
	q: cmdline window
	q/ history of search 
	<c-f> in cmdline to get cmdline windows

																	  *v#output*

	redir @a 
	redir END
	:write !sh # writes to the stdin of sh 
	:normal @a executes the macro in all lines o
	4!jsort filter with motion : sort the 4 next lines
	:r !ls     " read output from running ls, after current line
	:0r !ls    " after line 0 (before first line)
	:-r !ls    " before current line ("-" is ".-1")
	:redir >> out.txt
	:redir > out.txt
	:registers
	  " any other commands
	:redir END
	
	let @a=system('ls')

  	:1,10 w outfile 	Saves lines 1 to 10 in outfile
  	:1,10 w >> outfile 	Appends lines 1 to 10 to outfile
  	:r infile 	Insert the content of infile
  	:23r infile 	Insert the content of infile under line 23

  :r filename 	insert filename after cursor
  :10r filename 	insert filename after line 10
  :g/pattern/r filename 	search pattern and insert filename after cursor
  :r !shell-command 	insert the result of a shell-command after cursor
  !!shell-command 	insert command output in place of current line
  :r foo.txt    Insert the file foo.txt below the cursor.
  :0r foo.txt   Insert the file foo.txt before the first line.
  :r !ls        Insert a directory listing below the cursor.
  :$r !pwd      Insert the current working directory below the last line.
>vim
	" redirect ouput of a command in split window 
	function! OutputSplitWindow(...)
	  " this function output the result of the Ex command into a split scratch buffer
	  let cmd = join(a:000, ' ')
	  let temp_reg = @"
	  redir @"
	  silent! execute cmd
	  redir END
	  let output = copy(@")
	  let @" = temp_reg
	  if empty(output)
		echoerr "no output"
	  else
		new
		setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted
		put! =output
	  endif
	endfunction
	command! -nargs=+ -complete=command Output call OutputSplitWindow(<f-args>)
<vim



vim: ft=myhelp:tw=78:ts=4
