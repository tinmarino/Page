*v#regex.txt*       Regex, Search, Substitute, Global

VIM: NFA regular expression 

Forget me and go to :h pattern (or :h regex) that is super well written.
At least for the first chapter


1. Regex 						|v#regex|
 1. Escape Characters 			|v#escape|
 2. Quantifiers Greedy or not 	|v#quantifier|
2. Search						|v#search|
 1. Commands                    |v#search-modifier|
 1.             |v#search-modifier|
 1. Search modifiers            |v#search-modifier|
3. Sustitute 					|v#substitute|
4. Global						|v#global|

===============================================================================
1. Regex ~
http://vimregex.com/
                                                                    *v#escape*

Escaped caracter or metecaratcter ~
.  		    any character except new line 	  	 
\s 		    whitespace character 	
\S 		    no whitespace (upper case is the opposite)
\d 		    digit 	
\x 		    hex digit 	
\o 		    octal digit 	
\h 		    head of word character (a,b,c...z,A,B,C...Z and _) 	
\p 		    printable character 	
\w 		    word character 	
\a 		    alphabetic character 	
\l 		    lowercase character 	
\u 		    uppercase character

                                                                      *v#atom*
/\%x30 		Search hexa
/\%^, /\%$	Begining and end of document                                    
/\_.		Include newline
\@!         To negate ex: /^\(\(^.*cursor.*$\)\@!.*foo.*\)$

                                                                *v#quantifier*
Quantifiers ~
* 		    matches 0 or more of the preceding characters, ranges or metacharacters .* matches everything including empty line
\+ 		    matches 1 or more of the preceding characters...
\= 		    matches 0 or 1 more of the preceding characters...
\{n,m} 	    matches from n to m of the preceding characters...
\{n} 	    matches exactly n times of the preceding characters...
\{,m} 	    matches at most m (from 0 to m) of the preceding characters...
\{n,} 	    matches at least n of of the preceding characters...
\{-} 	    matches 0 or more of the preceding atom, as few as possible
\{-n,m}     	matches 1 or more of the preceding characters...
\{-n,} 	    matches at lease or more of the preceding characters...
\{-,m} 	    matches 1 or more of the preceding characters... 
                where n and m are positive integers (>0) 

===============================================================================
                                                                    *v#search*
Search ~

``[v``]       Reselect paste text
*, #        Search current word (backward)
g*, g#      Without word delimiter 
:noh		No hightlight search 
/word 	    word from top to bottom
?word 	    word from bottom to top
                                                            *v#search#example*
Example ~
\ze \zs     Regex start, stop
/jo[ha]n 	john or joan
/fred\|joe 	fred or joe
/\<the 		the, theatre or then
/the\> 	    the or breathe
/\<the\> 	the
/\<\d\{4}\> exactly 4 digits
/^\n\{3} 	empty lines
/\cstring   Case insensitive 
:bufdo /searchstr/ 	Search in all open files
/\<[A-Z]\+\/        or
/\v<[A-Z]+>         or 
/\<\u\+\>           Find upper case words
                                                          *v#search-modifiers*
Search modifiers ~
/joe/e              cursor set to End of match
3/joe/e+1           find 3rd joe cursor set to End of match plus 1 [C]
/joe/s-2            cursor set to Start of match minus 2
/joe/+3             find joe move cursor 3 lines down
/.*fred\&.*joe      Search for FRED AND JOE in any ORDER!

===============================================================================
                                                                *v#substitute*
Substite~
:range s[ubstitute]/pattern/string/cgiI 
c                   Confirm each substitution
g                   Replace all occurrences in the line (without g - only first).
i                   Ignore case for the pattern.
I                   Don't ignore case for the pattern.

:%s//\=@0           replace last search with register 0 content 
:&                  repeat last substitute cmd 
g&                  to make a replacement on all file lines ( equivalent to :%s//~/& (or :%&&) 

                                                        *v#substitute-example*

:%s/.*\(string_to_keep\).*/\1
:%s/\<./\u&/g 	    Sets first letter of each word to uppercase
:%s/\<./\l&/g 	    Sets first letter of each word to lowercase
:%s/.*/\u& 	        Sets first letter of each line to uppercase
:%s/.*/\l& 	        Sets first letter of each line to lowercase

:%!/^#/d            Selete lines not begining with #
^\(-*[0-9]*\.[0-9]*\s\)\{21}   
                    Match the 21 first numbers like 12232.23 23.23 
%s/^/\=line(".") . ". "/g    
                    Substitute all lines by its line number 
:4,$s/\d\+/\=submatch(0) + 1/ 
                    Add one to every number

<ESC>:%s/.*/\L&/    Tranform everything to lowar case
<ESC>:%s/.*/\U&/    Upper
/\<[A-Z]\+\/ or /\v<[A-Z]+> or /\<\u\+\> # find upper case words

:%s/.*/\L&/         Tranform everything to lowar case
:%s/.*/\U&/         Upper

:%s/\r//g 	        Delete DOS carriage returns (^M)
:%s/\r/\r/g 	    Transform DOS carriage returns in returns
:%s#<[^>]\+>##g 	Delete HTML tags but keeps text
:%s/^\(.*\)\n\1$/\1/ 	
                    Delete lines which appears twice

:s:\(\a*\a\):"\1":g \1 is like submatch(1)
:%s/identifying text \zs\d\+\(.\d\+\)\=/\=(1.15+str2float(submatch(0)))/
:%s/pattern \(saved portion\)\zs/\=SaverFunc(submatch(1))[-1]
:%call setline(line('.'),substitute(getline('.'),'foo','bar','g'))
1025,$s:^\(\d\+\.*\d*\)\s\+\(\d*\.*\d*\):\=printf("%f\t%f",submatch(1)/3.0, submatch(2) /3.0)
1025,$s:^\(\d*\)\s\+\(\d*\):\=submatch(1) . "\t" . submatch(2)*200
1025,$s:^(d*):=submatch(1)*200


===============================================================================
                                                *v#range*
Range ~

range 
  The '< Vim mark represents the beginning line of a visual region and the '> mark represents the ending line of the visual region


================================================================================
REGEX MATCH NUMBER ~
" Integer with - + or nothing in front
syn match celNumber '\d\+'
syn match celNumber '[-+]\d\+'

" Floating point number with decimal no E or e (+,-)
syn match celNumber '\d\+\.\d*'
syn match celNumber '[-+]\d\+\.\d*'

" Floating point like number with E and no decimal point (+,-)
syn match celNumber '[-+]\=\d[[:digit:]]*[eE][\-+]\=\d\+'
syn match celNumber '\d[[:digit:]]*[eE][\-+]\=\d\+'

" Floating point like number with E and decimal point (+,-)
syn match celNumber '[-+]\=\d[[:digit:]]*\.\d*[eE][\-+]\=\d\+'
syn match celNumber '\d[[:digit:]]*\.\d*[eE][\-+]\=\d\+'


																	  *v#global*
POWER of G  http://vim.wikia.com/wiki/Power_of_g
>vim
:v/./,/./-j					" delete duplicates
:g/{/ .+1,/}/-1 sort    	" sort lines betwenn { and }
:g/{/ .+1,/}/-1 >       	" indeent 
:g// 						" lists all lines containing the last search pattern, and :redir will capture the results. 
:g/pattern/m$			    " Move EOF
:g/^/m0			            " Reverse file
:g/pattern/y A		        " Yank appending to reg a
:v/string_to_keep/s/.*//    "
<vim
:g/^/put _                  " Double-space your file: 
:g/^/-put ='foo'.           "Add a line containing foo before each lineThis is
    " a clever use of the expression register. Here, - is a synonym for .-1 (cf.
    " :help :range). Since :put puts the text after the line, you have to explicitly
    " tell it to act on the previous one. aa


vim: ft=myhelp
