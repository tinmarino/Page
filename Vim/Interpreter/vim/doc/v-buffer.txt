*v#buffer.txt*      Window, Buffer, Tab


1. Split 		    |v#split|
2. Buffer 			|v#buffer|
3. Tab				|v#tab|

===============================================================================
                                                          *v#split* *v#window*
Split, Window ~


Modify Layout ~
<C-W>o          	| Only 
<C-W>q 				| Close current viewport
<C-W>x				| Swap position with next window or [count] next
<C-W>[rR]			| Rotate:(clockwise and counter) change viewport position 
<C-W>[+-]     		| Increase/decrease [count] Current Viewport height
<C-W>[<>]           | Increase/decrease [count] width
<C-W>=				| Igualise viewport size
<C-W>_				| Maximise current window height
<C-W>|				| Maximise current window width
<C-W>[HJKL] 		| Move the current window to the top of the screen, using the full width of the screen.

Move ~
<C-W><C-W> 			| Switch viewport 
<C-W>[hjkl]			| Move to the next viewport
<C-W><arrow>		| Move direction
<C-W>b              | Move to the bottom window
<C-W>t              | Move to the top window
<C-W>p              | MOve to previous window

Create ~
<C-W>s				| Split horizontal
<C-W>v				| Vertical split
<C-W>T				| Window to Tab
<C-W>n              | Split new

Jumps ~
<C-W>]              | Jump to the function whose name is under the cursor.
                      If a count is specified, it is the height of the new
                      window.
<C-W>g]             | Split followed a CTRL-]
<C-W>^              | Edit the alternate file.
                      If a count is specified, split the window and edit the
                      count file on the command line.
<C-W>d              | Find the definition of the word under the cursor.
                      If the definition cannot be found, do not split the window. <C-W><C-D>
<C-W>f              | Edit the file whose name is under the cursor. (like gf)
<C-W>g}             | Do a :ptjump on the word under the cursor.
<C-W>i              | Search for the count occurrence of the word under the cursor.
                      Start the search at the beginning of the file
<C-W>z              | Close preview window

Miscelanous ~
<C-W><C-C>          | Cancel window operation



Options ~
winheight           option When entering or creating a window, set its height to at least the specified value.
winwidth            option When entering or creating a window, set its width to at least the specified value.
equalalways         option When the number of windows changes, either by splitting or closing windows,
eadirection         option Define whether Vim resizes windows equally vertically, horizontally, or both.
cmdheight           option Set the command line height.
winminheight        option Define the minimum window height, which applies to all windows created.
winminwidth         option Define the minimum window width, which applies to all windows created.

Commands ~
:vertical resize n 
:resize 60 or :resize +5
:sp[lit]			| Split Screen horizontaly 
:vsp[lit]			| Split Screen vertically 
:sview 				| Same as :split in readonly mode
:hide 				| Close current window
:on[ly] 			| Close all windows, excepted current

z n <ENTER> Set the current window height to n.
Cw 10+ and Cw 10>
nnoremap <silent> <Leader>+ :exe "resize " . (winheight(0) * 3/2)<CR> nnoremap <silent> <Leader>- :exe "resize " . (winheight(0) * 2/3)<CR>
Some pluginng to use submodes permits Cw ++++
:new
:enew
:below new
set splitright set splitbelow


===============================================================================
                                                *v#buffer*
Buffer ~


:ls			        | display buffer list

:bn			        | new
:bd			        | delete
:b3			        | goto 3
:n :p			    | next, previous
:rew 			    | rewind to 1st file
:b#|bd#             | Delete current buffer going to alternate

:args 			    | display argument list
:arg 			    | Optional: Display the current arglist.
:arg *.cpp 		    | All *.cpp files in current directory.
:argadd *.h 		| And all *.h files.
:argdo %s/pattern/replace/ge | update 	
                    | Search and replace in all files in arglist. 

:update			    | save if changes
:bufdo 			    | do the command to all buffer
:e!   			    | return to unmodified file
:e #   			    | edit alternative file
:e +name		    | edit
:w /some/path/%:r 	| save file in another directory, but with the same name
:sav php.html     	| Save current file as php.html and "move" to php.html

:qa          		| quit all 


  bufdo normal 2G"Ayy "which iterates through the buffers and runs the given command in normal mode. 2G jumps to the appropriate line, and "Ay yanks into register a, appending instead of overwriting (since the A is capitalized). Make sure register a is empty before you start

===============================================================================
                                                *v#tab*
Tab ~

:tabnew 		    | Creates a new tab
:tabp			    | Go to previous tab 
:tabn			    | Go to next tab
:gt 			    | Show next tab
:tabfirst 		    | Show first tab
:tablast 		    | Show last tab
:tabm n(position) 	| Rearrange tabs
:tabdo %s/foo/bar/g | Execute a command in all tabs
:tab ball 		    | Puts all open files in tabs




vim: ft=myhelp
